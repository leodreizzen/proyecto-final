
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
import * as $runtime from "@prisma/client/runtime/client"

/**
 * @param _uuid
 */
export const getAffectedResolutions = $runtime.makeTypedQueryFactory("WITH RECURSIVE\n\nINITIAL_DIRTY AS (\nSELECT\nc.id AS entity_id,\n'CHANGE'::text AS entity_type,\nNULL::text AS res_init,\nNULL::int AS res_num,\nNULL::int AS res_year,\nNULL::int AS annex_num,\nNULL::int AS chap_num,\nNULL::int AS art_num,\nNULL::int AS art_suf,\n'INITIAL_TOGGLE'::text as reason,\n0 as depth,\nTRUE as should_expand\nFROM \"Change\" c\nWHERE c.id = ANY($1::uuid[])\n),\n\nDirtyScope(entity_id, entity_type, res_init, res_num, res_year, annex_num, chap_num, art_num, art_suf, reason, depth, should_expand) AS (\nSELECT entity_id, entity_type, res_init, res_num, res_year, annex_num, chap_num, art_num, art_suf, reason, depth, should_expand\nFROM INITIAL_DIRTY\n\nUNION ALL\n\nSELECT\nnext_victim.entity_id,\nnext_victim.entity_type,\nnext_victim.res_init, next_victim.res_num, next_victim.res_year,\nnext_victim.annex_num, next_victim.chap_num, next_victim.art_num, next_victim.art_suf,\nnext_victim.reason,\nscope.depth + CASE\nWHEN scope.res_num IS NULL THEN 0\nWHEN coords_match(\nnext_victim.res_init, next_victim.res_num, next_victim.res_year, NULL, NULL, NULL, NULL,\nscope.res_init, scope.res_num, scope.res_year, NULL, NULL, NULL, NULL\n) THEN 0\nELSE 1\nEND,\nnext_victim.should_expand\nFROM DirtyScope scope\nCROSS JOIN LATERAL (\n\nSELECT\nh.child_id AS entity_id,\nh.child_type AS entity_type,\nscope.res_init, scope.res_num, scope.res_year,\nCASE WHEN h.child_type = 'ANNEX' THEN ax.number ELSE scope.annex_num END AS annex_num,\nCASE WHEN h.child_type = 'CHAPTER' THEN ch.number ELSE scope.chap_num END AS chap_num,\nCASE WHEN h.child_type = 'ARTICLE' THEN a.number ELSE NULL END AS art_num,\nCASE WHEN h.child_type = 'ARTICLE' THEN a.suffix ELSE NULL END AS art_suf,\n'DESCENDENTS'::text AS reason,\nTRUE AS should_expand\nFROM \"v_Hierarchy\" h\nLEFT JOIN \"Article\" a ON h.child_id = a.id AND h.child_type = 'ARTICLE'\nLEFT JOIN \"Annex\" ax ON h.child_id = ax.id AND h.child_type = 'ANNEX'\nLEFT JOIN \"AnnexChapter\" ch ON h.child_id = ch.id AND h.child_type = 'CHAPTER'\nWHERE\nscope.entity_id IS NOT NULL\nAND scope.should_expand\nAND h.parent_id = scope.entity_id\nAND h.child_type IN ('ARTICLE', 'CHAPTER', 'ANNEX')\n\nUNION ALL\n\nSELECT\nc.id AS entity_id,\n'CHANGE'::text AS entity_type,\nscope.res_init, scope.res_num, scope.res_year, scope.annex_num, scope.chap_num, scope.art_num, scope.art_suf,\n'CONTAINED_CHANGES'::text AS reason,\nTRUE AS should_expand\nFROM \"ArticleModifier\" am\nJOIN \"Change\" c ON am.id = c.\"articleModifierId\"\nWHERE\nscope.entity_id IS NOT NULL\nAND scope.should_expand\nAND am.id = scope.entity_id\n\nUNION ALL\n\nSELECT\nCOALESCE(a.id, ax.id) AS entity_id,\ncm.entity_type,\ncm.res_init, cm.res_num, cm.res_year, cm.annex_num, cm.chap_num, cm.new_art_num, cm.new_art_suf,\n'NEW_CONTENT'::text AS reason,\nTRUE AS should_expand\nFROM \"v_ImpactMap\" im\nJOIN \"v_CreationMap\" cm ON im.change_id = cm.change_id\nLEFT JOIN \"Article\" a ON a.\"addedByChangeId\" = cm.change_id OR a.\"newContentFromChangeId\" = cm.change_id\nLEFT JOIN \"Annex\" ax ON ax.\"changeReplaceAnnexId\" = cm.change_id\nWHERE\nscope.should_expand\nAND scope.res_num IS NOT NULL\nAND coords_match(\nim.res_init, im.res_num, im.res_year, im.annex_num, im.chap_num, im.art_num, im.art_suf,\nscope.res_init, scope.res_num, scope.res_year, scope.annex_num, scope.chap_num, scope.art_num, scope.art_suf\n)\n\nUNION ALL\n\nSELECT\nref.native_id AS entity_id,\nim.target_type AS entity_type,\nim.res_init, im.res_num, im.res_year, im.annex_num, im.chap_num, im.art_num, im.art_suf,\n'CHANGE_IMPACT'::text AS reason,\nTRUE AS should_expand\nFROM \"v_ImpactMap\" im\nLEFT JOIN \"v_ResolvedReferences\" ref\nON coords_match(\nim.res_init, im.res_num, im.res_year, im.annex_num, im.chap_num, im.art_num, im.art_suf,\nref.res_init, ref.res_num, ref.res_year, ref.annex_num, ref.chap_num, ref.art_num, ref.art_suf\n) AND ref.target_type = im.target_type\nWHERE\nscope.entity_id IS NOT NULL\nAND im.change_id = scope.entity_id\n\nUNION ALL\n\nSELECT\nCOALESCE(a.id, ax.id) AS entity_id,\ncm.entity_type,\ncm.res_init, cm.res_num, cm.res_year, cm.annex_num, cm.chap_num, cm.new_art_num, cm.new_art_suf,\n'CHANGE_CREATION'::text AS reason,\nTRUE AS should_expand\nFROM \"v_CreationMap\" cm\nLEFT JOIN \"Article\" a ON a.\"addedByChangeId\" = cm.change_id OR a.\"newContentFromChangeId\" = cm.change_id\nLEFT JOIN \"Annex\" ax ON ax.\"changeReplaceAnnexId\" = cm.change_id\nWHERE\nscope.entity_id IS NOT NULL\nAND cm.change_id = scope.entity_id\n\nUNION ALL\n\nSELECT\nCOALESCE(direct_a.id, direct_ax.id, child_a.id) AS entity_id,\nCASE WHEN direct_cm.entity_type IS NOT NULL THEN direct_cm.entity_type ELSE 'ARTICLE'::text END AS entity_type,\nscope.res_init, scope.res_num, scope.res_year, scope.annex_num, scope.chap_num, scope.art_num, scope.art_suf,\n'LATE_RESOLUTION'::text AS reason,\nscope.should_expand AS should_expand\nFROM (SELECT 1) dummy\n\nLEFT JOIN \"v_CreationMap\" direct_cm ON\ncoords_match(\nscope.res_init, scope.res_num, scope.res_year, scope.annex_num, scope.chap_num, scope.art_num, scope.art_suf,\ndirect_cm.res_init, direct_cm.res_num, direct_cm.res_year, direct_cm.annex_num, direct_cm.chap_num, direct_cm.new_art_num, direct_cm.new_art_suf\n)\nLEFT JOIN \"Article\" direct_a ON direct_a.\"addedByChangeId\" = direct_cm.change_id OR direct_a.\"newContentFromChangeId\" = direct_cm.change_id\nLEFT JOIN \"Annex\" direct_ax ON direct_ax.\"changeReplaceAnnexId\" = direct_cm.change_id\n\nLEFT JOIN \"v_CreationMap\" parent_cm ON\nscope.art_num IS NOT NULL AND scope.annex_num IS NOT NULL AND\nparent_cm.entity_type = 'ANNEX' AND parent_cm.annex_num = scope.annex_num AND\nparent_cm.res_num = scope.res_num AND parent_cm.res_year = scope.res_year\nLEFT JOIN \"Annex\" parent_ax ON parent_ax.\"changeReplaceAnnexId\" = parent_cm.change_id\nLEFT JOIN \"AnnexChapter\" intermediate_ch ON intermediate_ch.\"annexId\" = parent_ax.id AND intermediate_ch.number = scope.chap_num\nLEFT JOIN \"Article\" child_a ON\nchild_a.number = scope.art_num AND child_a.suffix IS NOT DISTINCT FROM scope.art_suf AND\n(\n(scope.chap_num IS NULL AND child_a.\"annexId\" = parent_ax.id)\nOR\n(scope.chap_num IS NOT NULL AND child_a.\"chapterId\" = intermediate_ch.id)\n)\n\nWHERE\nscope.entity_id IS NULL\nAND (direct_a.id IS NOT NULL OR direct_ax.id IS NOT NULL OR child_a.id IS NOT NULL)\n\nUNION ALL\n\nSELECT\nres.id AS entity_id,\n'RESOLUTION'::text AS entity_type,\nUPPER(ref.res_init) AS res_init, ref.res_num, ref.res_year,\nNULL::int, NULL::int, NULL::int, NULL::int,\n'ADVANCED_IMPACT'::text AS reason,\nFALSE AS should_expand -- <--- RECURSION HALT\nFROM \"ChangeAdvanced\" ca\nJOIN \"v_ResolvedReferences\" ref ON ca.\"targetReferenceId\" = ref.native_id\nJOIN \"Resolution\" res ON\nres.number = ref.res_num AND\nres.year = ref.res_year AND\nUPPER(res.initial) = UPPER(ref.res_init)\nWHERE\nscope.entity_id IS NOT NULL\nAND scope.entity_id = ca.id\n\n) AS next_victim\nWHERE NOT scope.is_cycle\n)\nCYCLE entity_id, res_init, res_num, res_year, annex_num, chap_num, art_num, art_suf, should_expand SET is_cycle USING path\n\nSELECT\nCASE\nWHEN ref.target_type = 'RESOLUTION' THEN ref.native_id\nWHEN ref.target_type = 'ARTICLE' THEN ctx.\"rootResolutionId\"\nWHEN ref.target_type = 'ANNEX' THEN an.\"resolutionId\"\nELSE NULL\nEND AS id,\nMIN(ds.depth) as min_impact_depth\nFROM DirtyScope ds\nLEFT JOIN \"v_ResolvedReferences\" ref\nON coords_match(\nds.res_init, ds.res_num, ds.res_year, ds.annex_num, ds.chap_num, ds.art_num, ds.art_suf,\nref.res_init, ref.res_num, ref.res_year, ref.annex_num, ref.chap_num, ref.art_num, ref.art_suf\n)\nLEFT JOIN \"v_ArticleContext\" ctx ON ref.native_id = ctx.id AND ref.target_type = 'ARTICLE'\nLEFT JOIN \"Annex\" an ON ref.native_id = an.id AND ref.target_type = 'ANNEX'\nWHERE\nNOT ds.is_cycle\nAND (\n(ref.target_type = 'RESOLUTION' AND ref.native_id IS NOT NULL) OR\n(ref.target_type = 'ARTICLE' AND ctx.\"rootResolutionId\" IS NOT NULL) OR\n(ref.target_type = 'ANNEX' AND an.\"resolutionId\" IS NOT NULL)\n)\nGROUP BY 1;") as (_uuid: string[]) => $runtime.TypedSql<getAffectedResolutions.Parameters, getAffectedResolutions.Result>

export namespace getAffectedResolutions {
  export type Parameters = [_uuid: string[]]
  export type Result = {
    id: string | null
    min_impact_depth: number | null
  }
}
