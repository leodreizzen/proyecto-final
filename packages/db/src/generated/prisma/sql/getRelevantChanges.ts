
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
import * as $runtime from "@prisma/client/runtime/client"

/**
 * @param targetResolutionUUUID UUID of the target Resolution
 */
export const getRelevantChanges = $runtime.makeTypedQueryFactory("\nWITH RECURSIVE\n\nTargetResolutionScope(entity_id, entity_type, res_init, res_num, res_year, annex_num, chap_num, art_num, art_suf, is_main_tree, causing_change_id) AS (\nSELECT r.id, 'RESOLUTION', UPPER(r.initial), r.number, r.year, NULL::int, NULL::int, NULL::int, NULL::int, TRUE, NULL::uuid FROM \"Resolution\" r WHERE r.id = $1::uuid\nUNION ALL\nSELECT a.id, 'ANNEX', UPPER(r.initial), r.number, r.year, a.number, NULL::int, NULL::int, NULL::int, TRUE, NULL::uuid FROM \"Annex\" a JOIN \"Resolution\" r ON a.\"resolutionId\" = r.id WHERE r.id = $1::uuid\nUNION ALL\nSELECT c.id, 'CHAPTER', UPPER(r.initial), r.number, r.year, a.number, c.number, NULL::int, NULL::int, TRUE, NULL::uuid FROM \"AnnexChapter\" c JOIN \"AnnexWithArticles\" awa ON c.\"annexId\" = awa.id JOIN \"Annex\" a ON awa.id = a.id JOIN \"Resolution\" r ON a.\"resolutionId\" = r.id WHERE r.id = $1::uuid\nUNION ALL\nSELECT a.id, 'ARTICLE', UPPER(r.initial), r.number, r.year, NULL::int, NULL::int, a.number, a.suffix, TRUE, NULL::uuid FROM \"Article\" a JOIN \"Resolution\" r ON a.\"resolutionId\" = r.id WHERE r.id = $1::uuid\n),\n\nChangeDiscovery(entity_id, entity_type, res_init, res_num, res_year, annex_num, chap_num, art_num, art_suf, is_main_tree, causing_change_id) AS (\nSELECT entity_id, entity_type, res_init, res_num, res_year, annex_num, chap_num, art_num, art_suf, is_main_tree, causing_change_id FROM TargetResolutionScope\n\nUNION ALL\n\nSELECT next_step.entity_id, next_step.entity_type, next_step.res_init, next_step.res_num, next_step.res_year, next_step.annex_num, next_step.chap_num, next_step.art_num, next_step.art_suf, next_step.is_main_tree, next_step.causing_change_id\nFROM ChangeDiscovery scope\nCROSS JOIN LATERAL (\nSELECT im.change_id, NULL::text AS step_kind, NULL::uuid AS phys_id_lookup\nFROM \"v_ImpactMap\" im\nWHERE scope.res_num IS NOT NULL -- Guard\nAND im.res_num = scope.res_num AND im.res_year = scope.res_year AND im.res_init IS NOT DISTINCT FROM scope.res_init\nAND im.annex_num IS NOT DISTINCT FROM scope.annex_num\nAND (\nim.chap_num IS NOT DISTINCT FROM scope.chap_num\nOR (im.chap_num IS NULL AND scope.chap_num IS NOT NULL AND im.target_type = 'ARTICLE')\n)\nAND im.art_num IS NOT DISTINCT FROM scope.art_num AND im.art_suf IS NOT DISTINCT FROM scope.art_suf\nAND (im.impact_type = 'STRUCTURAL' OR (im.impact_type = 'CONTENT' AND scope.is_main_tree))\n\nUNION ALL\nSELECT NULL::uuid, 'ANCESTOR', scope.entity_id WHERE scope.entity_id IS NOT NULL\n\nUNION ALL\nSELECT NULL::uuid, 'CONTENT_EXPANSION', scope.entity_id WHERE scope.entity_id IS NOT NULL AND scope.is_main_tree AND scope.entity_type IN ('ANNEX', 'CHAPTER')\n) AS logic_trigger\nCROSS JOIN LATERAL (\n\nSELECT cm.change_id AS entity_id, cm.entity_type, cm.res_init, cm.res_num, cm.res_year, cm.annex_num, cm.chap_num, cm.new_art_num AS art_num, cm.new_art_suf AS art_suf, scope.is_main_tree, logic_trigger.change_id AS causing_change_id\nFROM \"v_CreationMap\" cm\nWHERE logic_trigger.change_id IS NOT NULL AND cm.change_id = logic_trigger.change_id\n\nUNION ALL\nSELECT cm.physical_origin_id AS entity_id, cm.entity_type, cm.src_res_init, cm.src_res_num, cm.src_res_year, NULL::int, NULL::int, NULL::int, NULL::int, FALSE AS is_main_tree, logic_trigger.change_id\nFROM \"v_CreationMap\" cm\nWHERE logic_trigger.change_id IS NOT NULL AND cm.change_id = logic_trigger.change_id AND cm.physical_origin_id IS NOT NULL\n\nUNION ALL\nSELECT logic_trigger.change_id AS entity_id, 'CHANGE'::text, NULL::text, NULL::int, NULL::int, NULL::int, NULL::int, NULL::int, NULL::int, scope.is_main_tree, logic_trigger.change_id WHERE logic_trigger.change_id IS NOT NULL\n\nUNION ALL\n\nSELECT\nh.parent_id,\nh.parent_type,\nCASE WHEN h.child_type = 'CHANGE' THEN art_data.initial ELSE scope.res_init END,\nCASE WHEN h.child_type = 'CHANGE' THEN art_data.number  ELSE scope.res_num END,\nCASE WHEN h.child_type = 'CHANGE' THEN art_data.year    ELSE scope.res_year END,\n\nCASE\nWHEN h.child_type = 'CHANGE' THEN art_data.annex_num -- Use Hydrated\nWHEN h.parent_type IN ('RESOLUTION') THEN NULL::int\nELSE scope.annex_num -- Preserve Annex when climbing Art->Annex or Chap->Annex\nEND,\n\nCASE\nWHEN h.child_type = 'CHANGE' THEN NULL::int\nWHEN h.parent_type IN ('RESOLUTION', 'ANNEX') THEN NULL::int\nELSE scope.chap_num\nEND,\n\nCASE WHEN h.child_type = 'CHANGE' THEN art_data.art_num ELSE NULL::int END,\nCASE WHEN h.child_type = 'CHANGE' THEN art_data.art_suf ELSE NULL::int END,\n\nCASE WHEN h.child_type = 'CHANGE' THEN FALSE ELSE scope.is_main_tree END,\nNULL::uuid\nFROM \"v_Hierarchy\" h\nLEFT JOIN (\nSELECT\na.id,\nUPPER(COALESCE(r1.initial, r2.initial, r3.initial)) as initial,\nCOALESCE(r1.number, r2.number, r3.number) as number,\nCOALESCE(r1.year, r2.year, r3.year) as year,\na.number as art_num,\na.suffix as art_suf,\nCOALESCE(an.number, an2.number) as annex_num\nFROM \"Article\" a\nLEFT JOIN \"Resolution\" r1 ON a.\"resolutionId\" = r1.id\nLEFT JOIN \"Annex\" an ON a.\"annexId\" = an.id\nLEFT JOIN \"Resolution\" r2 ON an.\"resolutionId\" = r2.id\nLEFT JOIN \"AnnexChapter\" ch ON a.\"chapterId\" = ch.id\nLEFT JOIN \"AnnexWithArticles\" awa ON ch.\"annexId\" = awa.id\nLEFT JOIN \"Annex\" an2 ON awa.id = an2.id\nLEFT JOIN \"Resolution\" r3 ON an2.\"resolutionId\" = r3.id\n) art_data ON h.child_type = 'CHANGE' AND h.parent_type = 'ARTICLE' AND h.parent_id = art_data.id\n\nWHERE logic_trigger.step_kind = 'ANCESTOR' AND h.child_id = logic_trigger.phys_id_lookup\n\nUNION ALL\nSELECT a.id, 'ARTICLE', scope.res_init, scope.res_num, scope.res_year, scope.annex_num, scope.chap_num, a.number, a.suffix, TRUE, NULL::uuid FROM \"Article\" a WHERE logic_trigger.step_kind = 'CONTENT_EXPANSION' AND (a.\"annexId\" = logic_trigger.phys_id_lookup OR a.\"chapterId\" = logic_trigger.phys_id_lookup)\nUNION ALL\nSELECT c.id, 'CHAPTER', scope.res_init, scope.res_num, scope.res_year, scope.annex_num, NULL::int, c.number, NULL::int, TRUE, NULL::uuid FROM \"AnnexChapter\" c WHERE logic_trigger.step_kind = 'CONTENT_EXPANSION' AND c.\"annexId\" = logic_trigger.phys_id_lookup\n\n) AS next_step\nWHERE next_step.entity_id IS NOT NULL OR next_step.causing_change_id IS NOT NULL\n)\nCYCLE entity_id SET is_cycle USING path\n\nSELECT DISTINCT cd.causing_change_id AS id, ctx.\"resDate\" AS date\nFROM ChangeDiscovery cd JOIN \"Change\" c ON cd.causing_change_id = c.id JOIN \"v_ArticleContext\" ctx ON ctx.id = c.\"articleModifierId\"\nWHERE cd.causing_change_id IS NOT NULL AND NOT cd.is_cycle;") as (targetResolutionUUUID: string) => $runtime.TypedSql<getRelevantChanges.Parameters, getRelevantChanges.Result>

export namespace getRelevantChanges {
  export type Parameters = [targetResolutionUUUID: string]
  export type Result = {
    id: string | null
    date: Date | null
  }
}
